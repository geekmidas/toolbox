import { existsSync, realpathSync } from 'node:fs';
import { mkdir, readFile, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import {
	generateOpenApi,
	OPENAPI_OUTPUT_PATH,
	openapiCommand,
	resolveOpenApiConfig,
} from '../openapi';
import type { GkmConfig } from '../types';
import {
	cleanupDir,
	createMockEndpointFile,
	createTempDir,
	createTestFile,
} from './test-helpers';

describe('resolveOpenApiConfig', () => {
	const baseConfig: GkmConfig = {
		routes: './src/endpoints/**/*.ts',
		envParser: './src/config/env#envParser',
		logger: './src/config/logger#logger',
	};

	it('should return disabled when openapi is false', () => {
		const result = resolveOpenApiConfig({ ...baseConfig, openapi: false });
		expect(result).toEqual({ enabled: false });
	});

	it('should return enabled with defaults when openapi is true', () => {
		const result = resolveOpenApiConfig({ ...baseConfig, openapi: true });
		expect(result).toEqual({
			enabled: true,
			title: 'API Documentation',
			version: '1.0.0',
			description: 'Auto-generated API documentation from endpoints',
		});
	});

	it('should return enabled by default when openapi is undefined', () => {
		const result = resolveOpenApiConfig({ ...baseConfig });
		expect(result.enabled).toBe(true);
	});

	it('should use custom config values when provided', () => {
		const result = resolveOpenApiConfig({
			...baseConfig,
			openapi: {
				enabled: true,
				title: 'My API',
				version: '2.0.0',
				description: 'Custom description',
			},
		});
		expect(result).toEqual({
			enabled: true,
			title: 'My API',
			version: '2.0.0',
			description: 'Custom description',
		});
	});

	it('should use defaults for missing optional config values', () => {
		const result = resolveOpenApiConfig({
			...baseConfig,
			openapi: { enabled: true },
		});
		expect(result).toEqual({
			enabled: true,
			title: 'API Documentation',
			version: '1.0.0',
			description: 'Auto-generated API documentation from endpoints',
		});
	});

	it('should be enabled by default when object provided without enabled field', () => {
		const result = resolveOpenApiConfig({
			...baseConfig,
			openapi: { title: 'Custom Title' },
		});
		expect(result.enabled).toBe(true);
	});
});

describe('generateOpenApi', () => {
	let tempDir: string;
	const originalCwd = process.cwd();

	beforeEach(async () => {
		tempDir = realpathSync(await createTempDir('openapi-gen-'));
		// Change to temp dir so output goes there
		process.chdir(tempDir);
	});

	afterEach(async () => {
		process.chdir(originalCwd);
		await cleanupDir(tempDir);
		vi.restoreAllMocks();
	});

	it('should return null when openapi is disabled', async () => {
		const config: GkmConfig = {
			routes: './src/endpoints/**/*.ts',
			envParser: './src/config/env#envParser',
			logger: './src/config/logger#logger',
			openapi: false,
		};

		const result = await generateOpenApi(config);
		expect(result).toBeNull();
	});

	it('should return null when no endpoints are found', async () => {
		const config: GkmConfig = {
			routes: './src/endpoints/**/*.ts', // Path doesn't exist
			envParser: './src/config/env#envParser',
			logger: './src/config/logger#logger',
		};

		const result = await generateOpenApi(config);
		expect(result).toBeNull();
	});

	it('should generate to fixed .gkm/openapi.ts path', async () => {
		await createMockEndpointFile(tempDir, 'test.ts', 'test', '/test', 'GET');

		const config: GkmConfig = {
			routes: `${tempDir}/**/*.ts`,
			envParser: './src/config/env#envParser',
			logger: './src/config/logger#logger',
			openapi: { enabled: true },
		};

		const result = await generateOpenApi(config, { silent: true });

		expect(result).not.toBeNull();
		expect(result?.endpointCount).toBe(1);
		expect(result?.outputPath).toBe(join(tempDir, OPENAPI_OUTPUT_PATH));
		expect(existsSync(join(tempDir, OPENAPI_OUTPUT_PATH))).toBe(true);
	});

	it('should generate TypeScript content', async () => {
		await createMockEndpointFile(tempDir, 'test.ts', 'test', '/test', 'GET');

		const config: GkmConfig = {
			routes: `${tempDir}/**/*.ts`,
			envParser: './src/config/env#envParser',
			logger: './src/config/logger#logger',
			openapi: { enabled: true },
		};

		await generateOpenApi(config, { silent: true });

		const content = await readFile(join(tempDir, OPENAPI_OUTPUT_PATH), 'utf-8');
		expect(content).toContain('// Auto-generated by @geekmidas/cli');
		expect(content).toContain('export const securitySchemes');
		expect(content).toContain('export interface paths');
	});

	it('should log no endpoints message when none found', async () => {
		const config: GkmConfig = {
			routes: `${tempDir}/nonexistent/**/*.ts`,
			envParser: './src/config/env#envParser',
			logger: './src/config/logger#logger',
			openapi: { enabled: true },
		};

		const consoleSpy = vi.spyOn(console, 'log');
		const result = await generateOpenApi(config);

		expect(result).toBeNull();
		expect(consoleSpy).toHaveBeenCalledWith(
			'No valid endpoints found for OpenAPI generation',
		);
	});
});

describe('openapiCommand', () => {
	let tempDir: string;
	const originalCwd = process.cwd();

	beforeEach(async () => {
		tempDir = realpathSync(await createTempDir('openapi-cmd-'));
	});

	afterEach(async () => {
		process.chdir(originalCwd);
		// Clean up any generated .gkm folder in current directory
		await rm(join(originalCwd, '.gkm'), { recursive: true, force: true });
		await cleanupDir(tempDir);
		vi.restoreAllMocks();
	});

	it('should generate OpenAPI client to .gkm/openapi.ts', async () => {
		await createMockEndpointFile(
			tempDir,
			'test.ts',
			'testEndpoint',
			'/test',
			'GET',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		// Change to temp dir so output goes there
		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		const outputPath = join(tempDir, OPENAPI_OUTPUT_PATH);
		expect(existsSync(outputPath)).toBe(true);

		const content = await readFile(outputPath, 'utf-8');
		expect(content).toContain('// Auto-generated by @geekmidas/cli');
	});

	it('should enable openapi with defaults when not configured', async () => {
		await createMockEndpointFile(
			tempDir,
			'test.ts',
			'testEndpoint',
			'/test',
			'GET',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('Found 1 endpoints'),
		);
		expect(existsSync(join(tempDir, OPENAPI_OUTPUT_PATH))).toBe(true);
	});

	it('should include endpoint auth map', async () => {
		await createMockEndpointFile(
			tempDir,
			'getUser.ts',
			'getUser',
			'/users/:id',
			'GET',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		const content = await readFile(join(tempDir, OPENAPI_OUTPUT_PATH), 'utf-8');
		expect(content).toContain('endpointAuth');
		expect(content).toContain("'GET /users/{id}'");
	});

	it('should handle no endpoints found', async () => {
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/nonexistent/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		expect(consoleSpy).toHaveBeenCalledWith(
			'No valid endpoints found for OpenAPI generation',
		);
	});

	it('should generate with multiple endpoints', async () => {
		await createMockEndpointFile(
			tempDir,
			'getUsers.ts',
			'getUsers',
			'/users',
			'GET',
		);
		await createMockEndpointFile(
			tempDir,
			'createUser.ts',
			'createUser',
			'/users',
			'POST',
		);
		await createMockEndpointFile(
			tempDir,
			'deleteUser.ts',
			'deleteUser',
			'/users/:id',
			'DELETE',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('Found 3 endpoints'),
		);
	});

	it('should create .gkm directory if it does not exist', async () => {
		await createMockEndpointFile(
			tempDir,
			'endpoint.ts',
			'testEndpoint',
			'/test',
			'GET',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		expect(existsSync(join(tempDir, '.gkm'))).toBe(true);
		expect(existsSync(join(tempDir, OPENAPI_OUTPUT_PATH))).toBe(true);
	});

	it('should throw error when config loading fails', async () => {
		process.chdir(tempDir);

		await expect(openapiCommand({ cwd: tempDir })).rejects.toThrow(
			/OpenAPI generation failed/,
		);
	});

	it('should throw error for invalid TypeScript files', async () => {
		await createTestFile(
			tempDir,
			'invalid.ts',
			'this is not valid typescript {[}]',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);

		await expect(openapiCommand({ cwd: tempDir })).rejects.toThrow(
			/OpenAPI generation failed/,
		);
	});

	it('should log generation success', async () => {
		await createMockEndpointFile(
			tempDir,
			'endpoint.ts',
			'testEndpoint',
			'/test',
			'GET',
		);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('OpenAPI client generated'),
		);
		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('Found 1 endpoints'),
		);
	});

	it('should handle endpoints with complex schemas', async () => {
		const complexEndpointContent = `
import { e } from '@geekmidas/constructs/endpoints';
import { z } from 'zod';

export const complexEndpoint = e
  .post('/complex')
  .body(z.object({
    user: z.object({
      name: z.string(),
      email: z.string().email(),
      age: z.number().optional(),
    }),
    tags: z.array(z.string()),
  }))
  .output(z.object({
    id: z.string(),
    status: z.enum(['active', 'inactive']),
  }))
  .handle(async () => ({ id: '123', status: 'active' as const }));
`;

		await createTestFile(tempDir, 'complex.ts', complexEndpointContent);

		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				routes: [`${tempDir}/**/*.ts`],
				openapi: { enabled: true },
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		const content = await readFile(join(tempDir, OPENAPI_OUTPUT_PATH), 'utf-8');
		expect(content).toContain('export interface paths');
	});
});

describe('openapiCommand - workspace mode', () => {
	let tempDir: string;
	const originalCwd = process.cwd();

	beforeEach(async () => {
		tempDir = realpathSync(await createTempDir('openapi-workspace-'));
	});

	afterEach(async () => {
		process.chdir(originalCwd);
		await cleanupDir(tempDir);
		vi.restoreAllMocks();
	});

	it('should generate OpenAPI for backend app in workspace', async () => {
		// Create workspace structure
		const apiDir = join(tempDir, 'apps/api');
		await mkdir(apiDir, { recursive: true });

		// Create endpoint in backend app
		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);

		// Create workspace config (gkm.config.json)
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
				},
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		// Should generate OpenAPI in the backend app's .gkm folder
		const outputPath = join(apiDir, OPENAPI_OUTPUT_PATH);
		expect(existsSync(outputPath)).toBe(true);

		const content = await readFile(outputPath, 'utf-8');
		expect(content).toContain('export interface paths');
		expect(content).toContain("'/users'");

		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('[api] Generated OpenAPI'),
		);
	});

	it('should copy OpenAPI to frontend app with client.output', async () => {
		// Create workspace structure
		const apiDir = join(tempDir, 'apps/api');
		const webDir = join(tempDir, 'apps/web');
		await mkdir(apiDir, { recursive: true });
		await mkdir(webDir, { recursive: true });

		// Create endpoint in backend app
		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);

		// Create workspace config with frontend that depends on backend
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					web: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/web',
						port: 3001,
						dependencies: ['api'],
						client: {
							output: './src/api',
						},
					},
				},
			}),
		);

		process.chdir(tempDir);
		const consoleSpy = vi.spyOn(console, 'log');

		await openapiCommand({ cwd: tempDir });

		// Should generate OpenAPI in backend app
		const backendOutput = join(apiDir, OPENAPI_OUTPUT_PATH);
		expect(existsSync(backendOutput)).toBe(true);

		// Should copy to frontend app's client output path
		const frontendOutput = join(webDir, 'src/api/openapi.ts');
		expect(existsSync(frontendOutput)).toBe(true);

		// Content should be the same
		const backendContent = await readFile(backendOutput, 'utf-8');
		const frontendContent = await readFile(frontendOutput, 'utf-8');
		expect(frontendContent).toBe(backendContent);

		expect(consoleSpy).toHaveBeenCalledWith(
			expect.stringContaining('[web] ./src/api/openapi.ts'),
		);
	});

	it('should only copy to frontend apps that depend on the backend', async () => {
		// Create workspace structure with multiple apps
		const apiDir = join(tempDir, 'apps/api');
		const authDir = join(tempDir, 'apps/auth');
		const webDir = join(tempDir, 'apps/web');
		const adminDir = join(tempDir, 'apps/admin');
		await mkdir(apiDir, { recursive: true });
		await mkdir(authDir, { recursive: true });
		await mkdir(webDir, { recursive: true });
		await mkdir(adminDir, { recursive: true });

		// Create endpoints
		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);
		await createMockEndpointFile(
			authDir,
			'src/endpoints/login.ts',
			'login',
			'/login',
			'POST',
		);

		// Create workspace config
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					auth: {
						type: 'backend',
						path: 'apps/auth',
						port: 3001,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					web: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/web',
						port: 3002,
						dependencies: ['api'], // Only depends on api
						client: {
							output: './src/api',
						},
					},
					admin: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/admin',
						port: 3003,
						dependencies: ['auth'], // Only depends on auth
						client: {
							output: './src/client',
						},
					},
				},
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		// Web should have api's OpenAPI (not auth's)
		const webApiOutput = join(webDir, 'src/api/openapi.ts');
		expect(existsSync(webApiOutput)).toBe(true);
		const webContent = await readFile(webApiOutput, 'utf-8');
		expect(webContent).toContain("'/users'");
		expect(webContent).not.toContain("'/login'");

		// Admin should have auth's OpenAPI (not api's)
		const adminClientOutput = join(adminDir, 'src/client/openapi.ts');
		expect(existsSync(adminClientOutput)).toBe(true);
		const adminContent = await readFile(adminClientOutput, 'utf-8');
		expect(adminContent).toContain("'/login'");
		expect(adminContent).not.toContain("'/users'");
	});

	it('should not copy to frontend with empty dependencies array', async () => {
		// Create workspace structure
		const apiDir = join(tempDir, 'apps/api');
		const webDir = join(tempDir, 'apps/web');
		await mkdir(apiDir, { recursive: true });
		await mkdir(webDir, { recursive: true });

		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);

		// Frontend with empty dependencies array (depends on nothing)
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					web: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/web',
						port: 3001,
						dependencies: [], // Empty array means depends on nothing
						client: {
							output: './src/api',
						},
					},
				},
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		// Should NOT copy to frontend since it has no dependencies
		const frontendOutput = join(webDir, 'src/api/openapi.ts');
		expect(existsSync(frontendOutput)).toBe(false);
	});

	it('should skip frontend apps without client.output', async () => {
		const apiDir = join(tempDir, 'apps/api');
		const webDir = join(tempDir, 'apps/web');
		await mkdir(apiDir, { recursive: true });
		await mkdir(webDir, { recursive: true });

		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);

		// Frontend without client.output
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					web: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/web',
						port: 3001,
						dependencies: ['api'],
						// No client.output configured
					},
				},
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		// Backend should still have OpenAPI generated
		expect(existsSync(join(apiDir, OPENAPI_OUTPUT_PATH))).toBe(true);

		// But no files should be created in frontend
		expect(existsSync(join(webDir, 'src/api/openapi.ts'))).toBe(false);
	});

	it('should handle nested client.output paths', async () => {
		const apiDir = join(tempDir, 'apps/api');
		const webDir = join(tempDir, 'apps/web');
		await mkdir(apiDir, { recursive: true });
		await mkdir(webDir, { recursive: true });

		await createMockEndpointFile(
			apiDir,
			'src/endpoints/users.ts',
			'getUsers',
			'/users',
			'GET',
		);

		// Deeply nested client output path
		await createTestFile(
			tempDir,
			'gkm.config.json',
			JSON.stringify({
				name: 'test-workspace',
				apps: {
					api: {
						type: 'backend',
						path: 'apps/api',
						port: 3000,
						routes: './src/endpoints/**/*.ts',
						openapi: { enabled: true },
					},
					web: {
						type: 'frontend',
						framework: 'nextjs',
						path: 'apps/web',
						port: 3001,
						dependencies: ['api'],
						client: {
							output: './src/lib/api/generated',
						},
					},
				},
			}),
		);

		process.chdir(tempDir);

		await openapiCommand({ cwd: tempDir });

		// Should create nested directories and file
		const frontendOutput = join(webDir, 'src/lib/api/generated/openapi.ts');
		expect(existsSync(frontendOutput)).toBe(true);

		const content = await readFile(frontendOutput, 'utf-8');
		expect(content).toContain('export interface paths');
	});
});
