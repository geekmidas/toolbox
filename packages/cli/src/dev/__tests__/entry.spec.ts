import { mkdir, readFile, rm } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { afterEach, beforeEach, describe, expect, it } from 'vitest';
import { createEntryWrapper, findSecretsRoot } from '../index';

describe('findSecretsRoot', () => {
	let testDir: string;

	beforeEach(async () => {
		testDir = join(tmpdir(), `gkm-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
		await mkdir(testDir, { recursive: true });
	});

	afterEach(async () => {
		await rm(testDir, { recursive: true, force: true });
	});

	it('should return startDir when no .gkm/secrets exists', () => {
		const result = findSecretsRoot(testDir);
		expect(result).toBe(testDir);
	});

	it('should find secrets in current directory', async () => {
		await mkdir(join(testDir, '.gkm', 'secrets'), { recursive: true });

		const result = findSecretsRoot(testDir);
		expect(result).toBe(testDir);
	});

	it('should find secrets in parent directory', async () => {
		const childDir = join(testDir, 'apps', 'auth');
		await mkdir(childDir, { recursive: true });
		await mkdir(join(testDir, '.gkm', 'secrets'), { recursive: true });

		const result = findSecretsRoot(childDir);
		expect(result).toBe(testDir);
	});

	it('should find secrets in grandparent directory', async () => {
		const grandchildDir = join(testDir, 'apps', 'auth', 'src');
		await mkdir(grandchildDir, { recursive: true });
		await mkdir(join(testDir, '.gkm', 'secrets'), { recursive: true });

		const result = findSecretsRoot(grandchildDir);
		expect(result).toBe(testDir);
	});

	it('should prefer closer secrets directory', async () => {
		// Create secrets in both parent and child
		const childDir = join(testDir, 'apps', 'auth');
		await mkdir(join(testDir, '.gkm', 'secrets'), { recursive: true });
		await mkdir(join(childDir, '.gkm', 'secrets'), { recursive: true });

		const result = findSecretsRoot(childDir);
		expect(result).toBe(childDir);
	});
});

describe('createEntryWrapper', () => {
	let testDir: string;

	beforeEach(async () => {
		testDir = join(tmpdir(), `gkm-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
		await mkdir(testDir, { recursive: true });
	});

	afterEach(async () => {
		await rm(testDir, { recursive: true, force: true });
	});

	it('should create wrapper without secrets injection', async () => {
		const wrapperPath = join(testDir, 'wrapper.ts');
		const entryPath = '/path/to/entry.ts';

		await createEntryWrapper(wrapperPath, entryPath, undefined);

		const content = await readFile(wrapperPath, 'utf-8');

		expect(content).toContain("await import('/path/to/entry.ts')");
		expect(content).not.toContain('Credentials');
		expect(content).toContain("Entry wrapper generated by 'gkm dev --entry'");
	});

	it('should create wrapper with secrets injection', async () => {
		const wrapperPath = join(testDir, 'wrapper.ts');
		const entryPath = '/path/to/entry.ts';
		const secretsPath = '/path/to/secrets.json';

		await createEntryWrapper(wrapperPath, entryPath, secretsPath);

		const content = await readFile(wrapperPath, 'utf-8');

		expect(content).toContain(
			"import { Credentials } from '@geekmidas/envkit/credentials'",
		);
		expect(content).toContain(secretsPath);
		expect(content).toContain('Object.assign(Credentials');
		expect(content).toContain("await import('/path/to/entry.ts')");
	});

	it('should inject secrets before entry import', async () => {
		const wrapperPath = join(testDir, 'wrapper.ts');
		const entryPath = '/path/to/entry.ts';
		const secretsPath = '/path/to/secrets.json';

		await createEntryWrapper(wrapperPath, entryPath, secretsPath);

		const content = await readFile(wrapperPath, 'utf-8');

		const credentialsIndex = content.indexOf('Credentials');
		const importIndex = content.indexOf("await import('/path/to/entry.ts')");

		expect(credentialsIndex).toBeGreaterThan(-1);
		expect(importIndex).toBeGreaterThan(-1);
		expect(credentialsIndex).toBeLessThan(importIndex);
	});

	it('should include shebang line', async () => {
		const wrapperPath = join(testDir, 'wrapper.ts');
		const entryPath = '/path/to/entry.ts';

		await createEntryWrapper(wrapperPath, entryPath, undefined);

		const content = await readFile(wrapperPath, 'utf-8');

		expect(content.startsWith('#!/usr/bin/env node')).toBe(true);
	});

	it('should handle Windows-style paths', async () => {
		const wrapperPath = join(testDir, 'wrapper.ts');
		const entryPath = 'C:\\Users\\test\\project\\src\\index.ts';

		await createEntryWrapper(wrapperPath, entryPath, undefined);

		const content = await readFile(wrapperPath, 'utf-8');

		expect(content).toContain(entryPath);
	});
});
