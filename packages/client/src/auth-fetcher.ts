import { TypedFetcher } from './fetcher';
import type {
	ExtractEndpointResponse,
	FetcherOptions,
	FilteredRequestConfig,
	TypedApiFunction,
	TypedEndpoint,
} from './types';

export type { FetcherOptions } from './types';

/**
 * Security scheme object matching OpenAPI 3.1 specification.
 */
export interface SecuritySchemeObject {
	type: 'apiKey' | 'http' | 'mutualTLS' | 'oauth2' | 'openIdConnect';
	description?: string;
	name?: string;
	in?: 'query' | 'header' | 'cookie';
	scheme?: string;
	bearerFormat?: string;
	flows?: Record<string, unknown>;
	openIdConnectUrl?: string;
	[key: string]: unknown;
}

/**
 * Extract all non-null security scheme IDs that are actually used in the API.
 * This gives us the union of scheme names that endpoints require.
 */
export type UsedSecuritySchemes<
	EndpointAuth extends Record<string, string | null>,
> = NonNullable<EndpointAuth[keyof EndpointAuth]>;

/**
 * Interface for token storage and retrieval.
 * Compatible with @geekmidas/auth TokenClient.
 */
export interface TokenProvider {
	/**
	 * Get a valid access token, refreshing if necessary.
	 */
	getValidAccessToken(): Promise<string | null>;

	/**
	 * Create Authorization headers from the current token.
	 */
	createValidAuthHeaders(): Promise<Record<string, string>>;
}

/**
 * Interface for API key providers.
 */
export interface ApiKeyProvider {
	/**
	 * Get the API key value.
	 */
	getApiKey(): Promise<string> | string;
}

/**
 * Interface for AWS SigV4 request signing.
 */
export interface AwsSigner {
	/**
	 * Sign a request with AWS SigV4.
	 * @param url - The request URL
	 * @param init - The request init object
	 * @returns Headers to add to the request
	 */
	sign(url: string, init: RequestInit): Promise<Record<string, string>>;
}

/**
 * Auth strategy configuration for a specific security scheme type.
 */
export type AuthStrategy =
	| { type: 'bearer'; tokenProvider: TokenProvider }
	| { type: 'apiKey'; apiKeyProvider: ApiKeyProvider; headerName?: string }
	| { type: 'iam'; signer: AwsSigner }
	| { type: 'none' };

/**
 * Options for creating an auth-aware fetcher.
 *
 * @template EndpointAuth - Map of endpoint strings to their auth scheme (or null for public)
 * @template SecuritySchemes - Available security scheme definitions
 */
export interface AuthFetcherOptions<
	EndpointAuth extends Record<string, string | null>,
	SecuritySchemes extends Record<string, SecuritySchemeObject>,
> extends Omit<FetcherOptions, 'onRequest'> {
	/**
	 * Runtime map of endpoints to their required auth scheme.
	 * Generated by `gkm openapi --ts`.
	 */
	endpointAuth: EndpointAuth;

	/**
	 * Security scheme definitions.
	 * Generated by `gkm openapi --ts`.
	 */
	securitySchemes: SecuritySchemes;

	/**
	 * Auth strategies for security schemes that are actually used.
	 * Only schemes referenced in endpointAuth are required.
	 *
	 * @example
	 * ```typescript
	 * // If endpointAuth has: { 'GET /users': 'jwt', 'POST /data': 'iam', 'GET /public': null }
	 * // Then authStrategies must include strategies for 'jwt' and 'iam'
	 * authStrategies: {
	 *   jwt: { type: 'bearer', tokenProvider },
	 *   iam: { type: 'iam', signer: awsSigner },
	 * }
	 * ```
	 */
	authStrategies: Record<UsedSecuritySchemes<EndpointAuth>, AuthStrategy>;

	/**
	 * Optional request interceptor (runs after auth headers are added).
	 */
	onRequest?: (config: RequestInit) => RequestInit | Promise<RequestInit>;
}

/**
 * Creates an auth-aware fetcher that automatically applies the correct
 * authentication based on the endpoint being called.
 *
 * @example
 * ```typescript
 * import { endpointAuth, securitySchemes, paths } from './openapi';
 * import { TokenClient } from '@geekmidas/auth/client';
 *
 * const tokenClient = new TokenClient({ ... });
 *
 * const api = createAuthAwareFetcher<paths>({
 *   baseURL: 'https://api.example.com',
 *   endpointAuth,
 *   securitySchemes,
 *   authStrategies: {
 *     bearer: { type: 'bearer', tokenProvider: tokenClient },
 *     iam: { type: 'iam', signer: awsSigner },
 *   },
 * });
 *
 * // Bearer auth automatically applied
 * const user = await api('GET /users/{id}', { params: { id: '123' } });
 *
 * // IAM SigV4 auth automatically applied
 * const tenant = await api('POST /tenants', { body: { name: 'Acme' } });
 * ```
 */
export function createAuthAwareFetcher<
	Paths,
	EndpointAuth extends Record<string, string | null> = Record<
		string,
		string | null
	>,
	SecuritySchemes extends Record<string, SecuritySchemeObject> = Record<
		string,
		SecuritySchemeObject
	>,
>(
	options: AuthFetcherOptions<EndpointAuth, SecuritySchemes> & {
		baseURL: string;
	},
): TypedApiFunction<Paths> {
	const {
		endpointAuth,
		securitySchemes,
		authStrategies,
		onRequest: userOnRequest,
		...fetcherOptions
	} = options;

	// Create base fetcher with user's onRequest if provided
	const baseFetcher = new TypedFetcher<Paths>({
		...fetcherOptions,
		onRequest: userOnRequest,
	});

	const fetcher = async <T extends TypedEndpoint<Paths>>(
		endpoint: T,
		config?: FilteredRequestConfig<Paths, T>,
	): Promise<ExtractEndpointResponse<Paths, T>> => {
		// Look up auth requirement for this endpoint
		const schemeName = endpointAuth[endpoint as keyof EndpointAuth] as
			| string
			| null;

		let authHeaders: Record<string, string> = {};

		if (schemeName) {
			const scheme = securitySchemes[schemeName as keyof SecuritySchemes];
			// Since authStrategies is now required to have all used schemes,
			// we can safely access it - TypeScript ensures the strategy exists
			const strategy =
				authStrategies[schemeName as UsedSecuritySchemes<EndpointAuth>];

			if (strategy && scheme) {
				authHeaders = await resolveAuthHeaders(strategy, scheme);
			}
		}

		// Merge auth headers with config headers
		const existingHeaders =
			config && 'headers' in config && config.headers
				? (config.headers as Record<string, string>)
				: {};

		const mergedConfig = {
			...config,
			headers: {
				...authHeaders,
				...existingHeaders,
			},
		} as unknown as FilteredRequestConfig<Paths, T>;

		return baseFetcher.request(endpoint, mergedConfig);
	};

	return fetcher as TypedApiFunction<Paths>;
}

/**
 * Resolves auth headers based on the strategy and scheme.
 */
async function resolveAuthHeaders(
	strategy: AuthStrategy,
	scheme: SecuritySchemeObject,
): Promise<Record<string, string>> {
	switch (strategy.type) {
		case 'bearer': {
			return strategy.tokenProvider.createValidAuthHeaders();
		}

		case 'apiKey': {
			const apiKey = await strategy.apiKeyProvider.getApiKey();
			const headerName = strategy.headerName || scheme.name || 'X-API-Key';

			if (scheme.in === 'header' || !scheme.in) {
				return { [headerName]: apiKey };
			}
			// Note: query and cookie API keys are handled differently
			// For now, we only support header-based API keys
			return {};
		}

		case 'iam': {
			// IAM signing requires the full URL and request config
			// This is a simplified version - full implementation would need
			// access to the complete request
			// For now, return empty - the actual signing should be done
			// in a custom onRequest interceptor if needed
			return {};
		}
		default:
			return {};
	}
}

/**
 * Type helper to extract the security scheme ID from an endpoint.
 */
export type GetEndpointAuth<
	EndpointAuth extends Record<string, string | null>,
	Endpoint extends keyof EndpointAuth,
> = EndpointAuth[Endpoint];

/**
 * Type helper to get all authenticated endpoints.
 */
export type AuthenticatedEndpoints<
	EndpointAuth extends Record<string, string | null>,
> = {
	[K in keyof EndpointAuth]: EndpointAuth[K] extends null ? never : K;
}[keyof EndpointAuth];

/**
 * Type helper to get all public endpoints.
 */
export type PublicEndpoints<
	EndpointAuth extends Record<string, string | null>,
> = {
	[K in keyof EndpointAuth]: EndpointAuth[K] extends null ? K : never;
}[keyof EndpointAuth];
